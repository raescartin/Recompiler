dec [0,8,16;1(16&17),7(0{0}&0{1}),0{2},18(6(0{0}&0{1}&5){0}&6(0{0}&0{1}&5){1}),19(9(8&5){0}&9(8&5){1})] = not [0{2};5] if [0{2},6(0{0}&0{1}&5){2},9(8&5){2};17]  root in: 

size:
0->3
8->1
16->1
1->2
7->2
18->2
6->3
5->1
19->2
9->3  but 8->1 5->1 ?¿?¿?¿ => 8->3 5->3 !!!!! 0{2}->3 !!!IMPOSSIBLE!!! 9->6 9{1}->4 19->5
17->1


dec [0;18(17&19)] = not [0{2};20] nand [0{2},20;21] and [20,21;19] dec [4(0{0}&0{1});7] rif [0{2},13(2(0{0}&0{1}&5){0}&2(0{0}&0{1}&5){1}),9(6(7&5){0}&6(7&5){1});17]  root in: 


FIX: O:
-evitar esta situación calculando nodos que pueden valer 1
-evitar esta situación permitiendo subnodos en los nodos extremos (no solo valor 1) ¿Cómo lo gestionas?
-evitar esta situación por construcción de las definiciones