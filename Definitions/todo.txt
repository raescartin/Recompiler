nandfusion

add [7(18&19&20),8(21&22&23);6(17&25)] = nand [23,20;36] or [23,20;42] and [42,36;25] nand [18,21;39] or [18,21;35] and [35,39;26] nand [19,22;43] or [22,19;37] and [37,43;27] and [22,19;28] and [20,23;29] add [16(26&27),15(28&29);17]  root in: 

add [7(0&1&2),8(3&4&5);6(17&12)] = xor [7(0&1&2),8(3&4&5);9(10&11&12)] and [13(1&2),14(4&5);15] add [16(10&11),15;17]  root in: 


if all the subnodes of a nodeOut have as ins subnodes of the same nodes nodeIn1 and nodeIn2, replace with nand(node2,node3,node1)

xor(a,b,c)= nand (a,b,x) or(a,b,y) and(x,y,c)

optimización(NO ES UN PROBLEMA, NO HAY INTERSECCIÓN)

xor [0,1;2] = nand [0,1;3] or [0,1;6] and [6,3;2]  root in: 
(creo que debería ser xor [0,1;2] = nand [0,1;3] or [0,1;4] and [3,4;2]  root in: 
causado por: or [0,1;2] = not [0;3] not [1;4] nand [3,4;2]  root in: 
que ESTÁ BIEN


nodos con fusion: and 25 xor 26 
problema con xor: no es simetrica: posibles soluciones
	-probar en ambos sentidos (coste exponencial)
	-ordenar nodos PROBAR A VER SI SE PUEDE HACER ESTO
		+ordenar instancias por orden alfabetico
		+ordenar nodos de menor a mayor!!!!!!!!
		
xor [0,1;2] = nand [0,1;3] or [0,1;6] and [6,3;2]
xor [7,3,11]= nand [7,3;18] or [3,7;21] and [21,18;11]  problema: 7,3!=3,7 ¡NO! Falla otra cosa: por alguna extraña razón confunde xor(3)

xor [0,1;2] = nand [0,1;3] or [0,1;6] and [6,3;2]  root in: 
xorTest [0,1;4] = or [0,1;2] nand [0,1;3] and [2,3;4]  root in: 

A veces optimiza bien xor y a veces no (al debuguearlo si y ejecutarlo no, etc...)
