FIXME:
unoptimized xor cost is 7

TODO
-decide if it's better to find new recursive definition ins/outs in definitions or nandForest
-recoverSupernodes after toNand,fromNand fine tunning (need to keep account of fissed nodes?)
-fix cost eval 
-fix toBest to be restrictive (subnodes etc... must be exactly the same to replace)
-sqrt
-add arrays of nodes to definition/try to implement algorithms with arrays
-todo: recursive intersection merge (if/rif)
-change Definition to Function
-fix Definition.toNandInstances() to work on recursive definitions (-> maybe create new function or fix optimize with this in mind) 

DONE
-remove need to break subnodes in nodeFission
-fix parentFission
-fix nodeFission
-fix childrenFission to break subnodes
-fix childrenFission to prevent redundant subnodes 
-fix expandInstancesMapping to prevent redundant subnodes 
-fix subnodes depth, now in instance eval is recursive on subnodes
-bug in intersection optimization, recursive definition keeps interesction (even if it's not needed)
-eval():nodeFission removes only instance on optimized rif
-fix fission:nandFission shoudn't remove any node
-fix optimization intersection between loop iterations
-aceptar nodos duplicados/equivalentes REDUNDANT SUBNODES en las estructuras definition
	-si no se puede trabajar con nodos duplicados entonces la estructura nodo tendrá que tener los tres subnodos hijo Y un vector de supernodos de los que forma parte
	-redundant subnodes are removed in nodeFission
-nodeFission includes node simplification/elimination of redundant subnodes
-fix fussion
-independent size of variables? 0(n)=0(1) (->cmp ->eq0 ->if) <-> recursive def if?¿
	-test a nand with one in bigger than the other (+nodes)
	-fill with 0 on left if the size of one input is less than expected (ifdef)
	FIXED length by now by design
-Optimize dropping ops before logical one or zero (already?). Remember to conserve size.
	-short-circuited?
-explore toBest  interaction with subnodes in instances (when can it be optimized?)
-fix eval of definitions
	-eval subnodes(children) of nodes if there are
	-consistent values when 1="1" 1{0} 1{1} and 1{2} (dividing undivisible nodes)
	-execute definition (to test) -> first iteration of recursive instances should be executed with missing inputs(rif==if)
	-always evaluate instances first, else nodes
-eval fixed
-change subnodes and supernodes to parents and children
-nodeFission
-nodeFussion
-fixed rootIn by traversing parents of root node
	i) remove rootIn of instanced root definition
	ii) trasnform
	iii) set rootIn of instance root to definition
-fixed toBest to work with subnodes
-get mul to work
	mul(a,b;c) d=0 add(a,d,d) b times c=d
	recursive mul:
	mul(a,b,c)= mul(a,b-1,d)&add(d,a,c)
-flatten on node eval (unique nodes)