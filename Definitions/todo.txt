-nodeFission includes node simplification?
-aceptar nodos duplicados/equivalentes REDUNDANT SUBNODES en las estructuras definition
	-si no se puede trabajar con nodos duplicados entonces la estructura nodo tendrá que tener los tres subnodos hijo Y un vector de supernodos de los que forma parte
-fix fission:nandFission shoudn't remove any node
-fix optimization intersection between loop iterations
-fix toBest to be restrictive (subnodes etc... must be exactly the same to replace)
-use mapLeft and mapRight INSTEAD of splitChildren()
-fix eval cost
-sqrt
-add arrays of nodes to definition
-todo: recursive intersection merge (if/rif)

DONE
-fix fussion
-independent size of variables? 0(n)=0(1) (->cmp ->eq0 ->if) <-> recursive def if?¿
	-test a nand with one in bigger than the other (+nodes)
	-fill with 0 on left if the size of one input is less than expected (ifdef)
	FIXED length by now by design
-Optimize dropping ops before logical one or zero (already?). Remember to conserve size.
	-short-circuited?
-explore toBest  interaction with subnodes in instances (when can it be optimized?)
-fix eval of definitions
	-eval subnodes(children) of nodes if there are
	-consistent values when 1="1" 1{0} 1{1} and 1{2} (dividing undivisible nodes)
	-execute definition (to test) -> first iteration of recursive instances should be executed with missing inputs(rif==if)
	-always evaluate instances first, else nodes
-eval fixed
-change subnodes and supernodes to parents and children
-nodeFission
-nodeFussion
-fixed rootIn by traversing parents of root node
	i) remove rootIn of instanced root definition
	ii) trasnform
	iii) set rootIn of instance root to definition
-fixed toBest to work with subnodes
-get mul to work
	mul(a,b;c) d=0 add(a,d,d) b times c=d
	recursive mul:
	mul(a,b,c)= mul(a,b-1,d)&add(d,a,c)
-flatten on node eval (unique nodes)