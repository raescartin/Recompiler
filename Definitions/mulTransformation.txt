(0) mul [0,1;2] = eq0 [0;3] zeros [0;4] dec [1;5] mul [0,5;6] add [6,0;7] rif [3,4,7;2]  root in: 
(1) mul [0,1,6;2,0,5] = eq0 [0;3] zeros [0;4] dec [1;5] add [6,0;7] rif [3,4,7;2]  root in: 
removedInstance: [mul [0,5;6] ]
(2)eq0 [0(1&2&3);5] = not [3;12] nand [3,12;13] nand [12,13;14] zeros [3;15] nand [3,15;16] nand [14,16;17] not [4;18] nand [18,17;19] and [17,19;5] zeros [1;7] zeros [2;8] cmp [6(7&8),9(1&2);4]  root in: 
mul [0(8&9&10),1,6;2,0(8&9&10),5] = zeros [0(8&9&10);4] not [10;11] nand [10,11;12] nand [11,12;13] zeros [10;14] nand [10,14;15] nand [13,15;16] not [17;18] nand [18,16;19] and [16,19;3] zeros [8;20] zeros [9;21] cmp [22(20&21),23(8&9);17]  root in: 
0->0
1->8
2->9
3->10
4->17
5->3
6->22
7->20
8->21
9->23
12->11
13->12
14->13
15->14
16->15
17->16
18->18
19->19
ok
(3)dec [0(1&2&3);7] = if [3,1,4;7] dec [8(1&2);4]  root in: 
mul [0(8&9&10),1(24&25&26),6;2,0(8&9&10),5] = zeros [0(8&9&10);4] not [10;11] nand [10,11;12] nand [11,12;13] zeros [10;14] nand [10,14;15] nand [13,15;16] not [17;18] nand [18,16;19] and [16,19;3] zeros [8;20] zeros [9;21] cmp [22(20&21),23(8&9);17] if [26,24,27;5] dec [28(24&25);27]  root in: 
0->1
1->24
2->25
3->26
4->27
7->5
8->28
ok
instanceOfRecursiveDef:[cmp [22(20&21),23(8&9);17] ]
recursiveInstances:[dec [28(24&25);27] ]
(4)rif [0,1(2&3&4),5(6&7&8);10(9&12)] = if [0,4,8;12] rif [0,13(2&3),16(6&7);9]  root in: mul,
rif [3,4,7;2] 
mul [0(8&9&10),1(24&25&26),6;2(35&36),0(8&9&10),5] = zeros [0(8&9&10);4(29&30&31)] not [10;11] nand [10,11;12] nand [11,12;13] zeros [10;14] nand [10,14;15] nand [13,15;16] not [17;18] nand [18,16;19] and [16,19;3] zeros [8;20] zeros [9;21] cmp [22(20&21),23(8&9);17] if [26,24,27;5] dec [28(24&25);27] if [3,31,34;36] rif [3,37(29&30),38(32&33);35]  root in: 
0->3
1->4
2->29
3->30
4->31
5->7
6->32
7->33
8->34
9->35
10->2
12->36
13->37
16->38
ok
(5)add [0(1&2&3),4(5&6&7);9(8&11)] = xor [3,7;11] xor [1,5;13] xor [2,6;14] and [2,6;16] and [3,7;17] add [12(13&14),15(16&17);8]  root in:
add [6,0(8&9&10);7(32&33&34)] 
 
mul [0(8&9&10&42&43&44),1(24&25&26),6(39&40&41);2(35&36),0(8&9&10&42&43&44),5] = zeros [0(8&9&10&42&43&44);4(29&30&31)] not [10;11] nand [10,11;12] nand [11,12;13] zeros [10;14] nand [10,14;15] nand [13,15;16] not [17;18] nand [18,16;19] and [16,19;3] zeros [8;20] zeros [9;21] cmp [22(20&21),23(8&9);17] if [26,24,27;5] dec [28(24&25);27] if [3,31,34;36] rif [3,37(29&30),38(32&33);35] xor [41,44;46] xor [39,42;47] xor [40,43;48] and [40,43;49] and [41,44;50] add [51(47&48),52(49&50);45]  root in: 
0->6
1->39
2->40
3->41
4->0
5->8
6->9
7->10
9->7
xor [41,10;11] xor [1,5;13]

Problema:9(8&11)->7(32&33&34)]    sol1:8->x(32&33)       sol2:partir siempre en 3 y si necesitas dos usar el join sol3:allow multiple combinations of subnodes
									   11->34				IMPOSIBLE, porque el join ser√° un nodo con dos subnodos														                                        9<->42
																																		9(8&11) 42(32&33&34)
									buscar

otra posibilidad: separar siempre en dos y recursividad siempre por la izquierda
MEJOR IDEA: recombinar nodos: nuevo nodo, agregar como hijos los hijos del anterior No se puede :/



INS EASY: subdivide
OUTS DIFFICULT:
